# Angular Redux Data

This project is intended to provide an complete data layer framework for Angular 7+ applications. Angular Redux Data (ARD)
utilizes [@ngrx](https://github.com/ngrx/platform) and relative libraries to provide redux state management without the developer needing to create excessive
and redundant boilerplate code for a standard data schema. The framework also provides a standard DataLayerService to be used
with HTTP RESTful and Websocket based apis.

**_NOTE_** developers using this library will benefit from having a fundamental understanding of [REDUX and @ngrx](https://ngrx.io/).
However, this knowledge is not required if the application will only be using ARD as a standardized data layer solution.

## Project Status

~~Initialized~~ -> ~~Under Construction~~ -> ~~Alpha~~ -> **Beta** -> Production

## Getting Started

The following setup steps are to configure an Angular 7+ application to access data from the [JSONplaceholder](https://jsonplaceholder.typicode.com/)
public api.

####Installation

---
In order to use the ARD framework your angular application must be versioned `^7.1.0`.
Simply install the framework as:

`npm install --save angular-redux-data`

####Setup

ARD aims to minimize if not eliminate all of the code overhead that typically comes with Redux based state manage and 
creating extensive data layer services in Angular application. Large applications can have tens to hundreds of models in
their schema which can make Redux and Angular data layers very difficult to maintain and test. ARD needs
only a few configuration steps to provide you with UI layer access to all your schema's data.

#####Configuration

######environment variables

In your project, create a configuration object with the following properties:

```typescript
export const angularReduxDataConfig = {
  effects: [],
  entityNameSpaces: [],
  defaultHost: '',
  defaultPath: '',
  entityAdapterMappings: {},
  customReducers: {}
};
```

**Effects  (Required)**:
This is a list of the ngrx effects services that you will define to handle the standard side effects generated by ARD.
There must be an effect service for every entityNamespace provided in order to execute api communication. 
_Example_: 
```typescript
import {CommentEffects} from '../effects/comment.effects';
import {PostEffects} from '../effects/post.effects';
effects: [
    CommentEffects,
    PostEffects
]
```

**EntityNameSpaces  (Required)**:
This is a list of strings for every model in your applications schema. The string provided should be singular or plural based on
the endpoint of the api you will be connecting to for that model. If the path to access _post_ data in your api is `/api/posts` then
you will define the entity namespace as `'posts'`. Where if the endpoint to access a user's profile is `/api/profile` then 
you will define the namespace as `'profile'`


_Example_: 
```typescript
entityNameSpaces: [
    'posts',
    'comments',
    'profile',
    'breeds',
    'events'
]
```

**defaultHost (Required)**:
This is the host location that the data layer will default to given no custom entity adapter is provided (see **entityAdapterMappings**).

*The default host should **not** end in a back slash

_example_
```typescript
defaultHost: 'https://jsonplaceholder.typicode.com'
```

**defaultPath (Required)**:
This is the default base path the the data layer will append to the default host given no custom entity adapter configuration.
The host and path concatenated form the base of the endpoint url.

*The default path should **not** end in a back slash

```typescript
defaultPath: 'api/v1'
```


**entityAdapterMappings**

It is possible to have a different api for one or many of the models in the schema of your application. This feature enables an 
application to use ARD no matter how the api(s) for the various models are structured. The first step in defining a custom adapter is
to create an adapter class that extends the ARD `DataAdapter` class if you have the need to customize how you interface with a paticular API.
If you are simply defining a separate endpoint but the REST patterns are standard then simply extend the `ApplicationHttpAdapter` class.

_**example** adapter with standard REST API patterns (no need to override methods)_:

```typescript
import { ApplicationHttpAdapter } from 'angular-redux-data';
import { Store } from '@ngrx/store';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs/';
export class CatsAdapter extends ApplicationHttpAdapter {

    constructor(protected _http: HttpClient,
                protected _host: string,
                protected _path: string,
                protected _store: Store<any>) {
        super(_http, _host, _path, _store);
    }
}
```

_**example** adapter with standard REST API patterns (no need to override methods)_:

```typescript
import {HttpClient, HttpHeaders} from '@angular/common/http';
import {Store} from '@ngrx/store';
import {DataAdapter} from 'angular-redux-data';
import {Observable, throwError} from 'rxjs';
import {catchError, distinctUntilChanged, filter, map} from 'rxjs/operators';

export class TicketMasterAdapter extends DataAdapter {
    private apiKey: string;

    constructor(protected http: HttpClient,
                protected host: string,
                protected path: string,
                protected store: Store<any>) {
        super(http, host, path, store);
        // Example of how to utilize an auth token in the adapter class
    }
    
    // Implemented Method
    createRecord(type: string, data: any): Observable<any> {
        // API interface code
    }
    
    // Implemented Method
    deleteRecord(type: string, recordId: number | string): Observable<any> {
                // API interface code
    }

    // Implemented Method
    findAll(type: string, config?: {}): Observable<any[]> {
              // API interface code
    }

    // Implemented Method
    findRecord(type: string, recordId: number | string, config?: {}): Observable<any> {
               // API interface code
    }

    queryAll(type: string, params: {}): Observable<any> {
               // API interface code
    }

    // Implemented Method
    updateRecord(type: string, recordId: number | string, data): Observable<any> {
        // API interface code
    }
}

```

After your custom adapters have been defined you can then define the `entityAdapterMappings` object in your ARD configuration. Using the two 
examples above the object would look like:

```json
 entityAdapterMappings: {
            'breeds': {
                adapter: CatsAdapter,
                host: 'https://api.thecatapi.com',
                path: 'v1'
            },
            'events': {
                adapter: TicketMasterAdapter,
                host: 'https://app.ticketmaster.com',
                path: 'discovery/v1'
            }
        },
        customReducers: {
            'uiState': uiState
        }
 }
```

**customReducers**:

ARD enables you to easily establish REDUX state patterns outside the data layer where the flows are specific to the application or component(s) state.
This is done in a similar manner to how you would pass reducers references in the NgRx `StoreModule`. [@ngrx](https://ngrx.io/guide)

**_example_**:
```typescript
import {uiState} from '../app/<path to reducer>/uiStateReducer';

customReducers: {
            'uiState': uiState
        }
```


FULL EXAMPLE:

```typescript
export const reduxDataServiceConfig: {
     effects: [ // These references are explained in the following section: entity effects
         CommentEffects,
         PostEffects,
         ClientEffects,
         ProfileEffects,
         BreedEffects,
         EventEffects
     ],
     entityNameSpaces: [
         'posts',
         'comments',
         'clients',
         'profile',
         'breeds',
         'events'
     ],
     defaultHost: 'https://jsonplaceholder.typicode.com',
     defaultPath: '',
     entityAdapterMappings: {
         'breeds': {
             adapter: CatsAdapter,
             host: 'https://api.thecatapi.com',
             path: 'v1'
         },
         'events': {
             adapter: TicketMasterAdapter,
             host: 'https://app.ticketmaster.com',
             path: 'discovery/v1'
         }
     },
     customReducers: {
         'uiState': uiState
     }
 }
```

######app.module

After your configuration is completed all you have to do is import the following modules into your `app.module.ts` and pass the configuration
object in as follows:

```typescript
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import {reduxDataServiceConfig} from '../<path to configuration object>'
import { AngularReduxDataLayerModule, AngularReduxDataModule, ReduxDataReducerFactory } from 'angular-redux-data';
import { StoreDevtoolsModule, StoreDevtoolsOptions } from '@ngrx/store-devtools';
import { StoreModule } from '@ngrx/store';
import { EffectsModule } from '@ngrx/effects';
import { AppComponent } from './app.component';

@NgModule({
    declarations: [
        AppComponent
    ],
    imports: [
        BrowserModule,
        AngularReduxDataModule.forRoot(reduxDataServiceConfig),
        AngularReduxDataLayerModule.forRoot(reduxDataServiceConfig),
        StoreModule.forRoot(ReduxDataReducerFactory.getReducers(
            reduxDataServiceConfig.entityNameSpaces, reduxDataServiceConfig.customReducers
            )
        ),
        EffectsModule.forRoot(reduxDataServiceConfig.effects),
        StoreDevtoolsModule.instrument(<StoreDevtoolsOptions>{maxAge: 25}),
    ],
    providers: [],
    bootstrap: [AppComponent]
})
export class AppModule {
}
```
######entity effects
 

In order retrieve data from your api endpoint(s) you will need to setup a  [@ngrx/effects](https://ngrx.io/guide/effects) service for
every model in your schema. 

ARD streamlines the data layer interaction for ngrx/effects in Angular application via the `DataLayerService` that is established in the 
`app.module.ts`. 

In each Effects service that you want to utilize the data layer adaptor simply extend the AngularReduxDataEffect and pass the namespace into 
the `super()` constructor argument.

```typescript
import {Injectable} from '@angular/core';
import {Actions, Effect} from '@ngrx/effects';
import {AngularReduxDataEffect} from 'angular-redux-data';
import {ReduxDataActionsService} from 'angular-redux-data';
import {DataLayerService} from 'angular-redux-data';

@Injectable()
export class BreedEffects extends AngularReduxDataEffect {
    @Effect() findAll$;
    @Effect() findRecord$;
    @Effect() create$;
    @Effect() delete$;
    @Effect() update$;
    @Effect() queryAll$;
    constructor(protected actions$: Actions, protected actionsService: ReduxDataActionsService,
                protected dataLayerService: DataLayerService) {
        super(actions$, actionsService, dataLayerService, 'breeds');
    }
}
```

The definition of these files will be what are referenced in your AngularReduxData configuration object.

#####Use

Using Angular Redux Data to read and manipulate data from your api(s) is exceedingly simple. There are several basic functions
that should enable almost every application to accomplish its data interfacing goals. Simply inject the `AngularReduxDataService` into
any component that needs to access data. 

```typescript
 constructor(private _ard: AngularReduxDataService) {}
```

######Reading Data

There are three functions that enable reading of data for your schema:

**Find All**

```typescript
    this._ard.findAll('posts').subscribe(posts$ => {
        this.posts = posts$;
    }, (err) => {
        console.log('error communicating with api', err)
    })
```

**Find Record**

```typescript
    this._ard.findRecord('posts', 1).subscribe(postWithIdEqualTo1$ => {
        this.post = postWithIdEqualTo1$;
    }, (err) => {
        console.log('error communicating with api', err)
    })
```

**Query All**

```typescript
    this._ard.queryAll('comments', {postId: this.post.id}).subscribe(comments$ => {
        this.post['comments'] = comments$;
    });
```

**Peek All**

```typescript
this._ard.peekAll('posts').subscribe(posts$ => this.postList = posts$);
```
**Peek Record**

```typescript
this._ard.peekRecord('posts', 1).subscribe(post$ => this.post = post$);
```
**Peek By**
```typescript
this._ard.peekBy('comments', {postId: this.post.id}).subscribe(comments$ => this.post.comments = comments$);

```

######Writing Data

**Create**

```typescript
 this._ard.create('posts', {
            'title': 'testing post',
            'author': 'meow'
        }).subscribe((post$) => {
            //Will only emit once when creation flow is completed
            this.newlyCreatedPost = post$;
        });
```

**Update**

```typescript
 this._ard.update('posts', 1, {meow: 'mix'})
            .subscribe(updatedPost$ => {
                //Will only emit once when creation flow is completed
            });
```

**Delete**


```typescript
this._ard.delete('posts', this.newlyCreatedPost.id)
            .subscribe(deleted$ => {
               //Will only emit once when creation flow is completed
            });
```
